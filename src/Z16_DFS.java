/**
 * 비선형 자료 구조에서 (그래프) 문제에서  모든 정점을 빠짐없이 순회하는 방법
 * DFS BFS(너비 우선 탐색) 등등 
 * DFS 깊이 우선 탐색: 스택 자료구조가 필요하다 
 * BFS 너비 우선 탐색: 큐 자료 구조가 필요하다 
 * 
 * input 
 *  	1 2/ 1 3/2 4 /2 5 /4 6 /5 6 /6 7/ 3 7
 * 
 * output ( DFS로 순회하면서 정점을 출력, 1번 정점부터 시작)
 * 
 *    1 2 4 6 5 7 3 
 * 또는 1 3 7 6 5 2 4
 * 
 * 
 * 
 */



public class Z16_DFS {

	public static void main(String[] args) {
		int [][] gra = { // 정점에 연결된 정보를 저장
				{}, // 0번 정점에 인접한 정점 - 0번 정점은 안쓴다 .
				{2,3}, // 1번 정점에 인접한 정점
				{1,4,5}, // 2번 정점에 인접한 정점
				{1,7}, // 3번 정점에 인접한 정점
				{2,6}, // 4번 정점에 인접한 정점
				{2,6}, // 5번 정점에 인접한 정점
				{4,5,7}, // 6번 정점에 인접한 정점
				{3,6}, // 7번 정점에 인접한 정점
			};
		int [] stack = new int [20];//부족하지 않게 스택의 크기를 지정
		int top = -1; // 스택에 index를 관리할 변수
		boolean [] visited = new boolean [8]; 
		// 각 정점의 방문여부
		
		// 시작 정점을 하나 지정하여, 시작 정점을 방문, 스택에 시작정점을 넣고,
		//반복을 시작
		int v = 1; // 시작정점을 지정, 1A를 의미
		visited[v] = true; // 방문 체크 
		System.out.print(v + " ");//  방문하면 정점을 출력
		
		stack[++top] = v;// 마지막 갈림길을 스택에 저장
		// 반복 시작 : 스택이 비워질때까지 반복, 스택에서 정점을 꺼내 , 
		// 인접한&& 방문하지 않은 정점을
		// 방문 작업을 반복한다
		while(top>-1) {
			int w = -1; // 다음 정점을 저장할 변수를 미리 선언, 플레그 변수 역할도 겸한다 
			for (int i = 0; i < gra[v].length; i++) {// v정점에 인접한 정점만큼 반복
				 // 방문하지 않은 정적이면, 방문하기
				if(!visited[gra[v][i]]) {
					w = gra[v][i]; //  다음에 갈 정점을 w로 저장
					
					stack [++top]=w;
					visited[w] = true; // 방문 여부를 체크
					System.out.print(w+ " "); // 1 2 4 6 5 7 3
					v = w;
					break;// 인접한 정점중 방문하지 않은  정점을 찾으고 고고, for문  종료
				}
				
			}
			if(w == -1) { //  인접한 정점중, 방문하지 않은 정점이 없는 것이다(막다른 골목)
			v = stack [top--];
			
			}
		
		
		}
	}//main
	
}//class
